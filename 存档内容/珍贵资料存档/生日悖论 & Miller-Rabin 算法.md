Coffee_zzz の Blog <https://www.luogu.com.cn/blog/CuteCfz/sheng-ri-bei-lun-miller-rabin-suan-fa>

今天心血来潮，想来研究一下生日悖论这个东西，也学习一下 Miller-Rabin 算法。本来还想学学 Pollard-Rho 算法，但是咕咕咕了。

## 1.1 生日悖论的介绍

首先放一下百度百科对于它的介绍：

> 生日悖论是指在不少于 $23$ 个人中至少有两人生日相同的概率大于 $50\%$。例如在一个 $30$ 人的小学班级中，存在两人生日相同的概率为 $70\%$。对于 $60$ 人的大班，这种概率要大于 $99\%$。从引起逻辑矛盾的角度来说，生日悖论是一种 “佯谬”。但这个数学事实十分反直觉，故称之为一个悖论。生日悖论的数学理论被应用于设计密码学攻击方法——生日攻击。

生日悖论确实很反直觉，但你不得不承认事实确实是这样。

## 1.2 生日问题的解法

我们讨论一年有 $365$ 天的情况。

令 $N=365$，设 $P(x)$ 表示在 $x$ 个人中，至少有两人生日相同的概率，其中 $x$ 为不大于 $N$ 的自然数。

想要计算 $P(x)$，我们可以先考虑计算它的反面：在 $x$ 个人中，不存在两人生日相同的概率。我们不妨设这个概率为 $P'(x)$，其中 $x$ 也为不大于 $N$ 的自然数。

根据 $P'(x)$ 的定义，我们可以轻松得到 $P'(x)$ 的递推公式：

$$
P'(x)=
\begin{cases}
1 & x=1\\
P'(x-1)\cdot \dfrac {N-x+1} N & \text{otherwise}
\end{cases}
$$

拆开可以得到：

$$
\begin{aligned}
P'(x)&=\prod\limits_{i=1}^{i\le x} \dfrac {N-i+1} N\\
&=\dfrac{N!}{N^x\cdot (N-x)!}
\end{aligned}
$$

由于 $P(x)+P'(x)=1$，所以：

$$
\begin{aligned}
P(x)&=1-P'(x)\\
&=1-\dfrac{N!}{N^x\cdot (N-x)!}
\end{aligned}
$$

于是我们就得到了在 $x$ 个人中，至少有两人生日相同的概率 $P(x)$。

当然，如果在 OI 方面计算 $P(x)$ 的近似值还是用 $P(x)=1-\prod\limits_{i=1}^{i\le x} \dfrac {N-i+1} N$ 这个公式方便一些。

当 $x=23$ 时，代入可得 $P(x)>50\%$，从而证明了生日悖论。

生日问题还有个近似解法，~~但是我不会~~，所以我就只挂个百度百科的链接了：[Link](https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290?fr=ge_ala#1_2)。

## 2.1 费马素性检验

暴力判断一个数是否是素数是简单的，我们可以在 $\mathcal O(\sqrt n)$ 的时间内解决。

但是这并不满足于我们，我们需要一个更高效的算法去进行素性检验。

我们都知道费马小定理：

> 若 $p$ 为素数，则对于任意小于 $p$ 的自然数 $a$，都满足 $a^{p-1} \equiv 1 \pmod p$。

我们考虑它的逆否命题：

> 若存在小于 $p$ 的自然数 $a$，满足 $a^{p-1} \not\equiv 1 \pmod p$，则 $p$ 不为素数。

那我们随机选取一些小于 $p-1$ 的自然数，用快速幂判断一下即可。

如果存在快速幂的结果不为 $1$，则 $p$ 一定不是素数，否则 $p$ 大概率是素数。这个方法就是**费马素性检验**。

但是，仍存在一些合数 $p$，满足不存在小于 $p$ 的自然数 $a$ 满足 $a^{p-1} \not\equiv 1 \pmod p$，例如 $561,1105,1729$ 等。这些数被称为卡迈克尔数，又被称为费马伪素数。

于是，我们需要对费马素性检验进行优化。

## 2.2 二次探测定理

我们引入二次探测定理：

> 若 $p$ 为奇素数，则 $x^2\equiv 1 \pmod p$ 的解为 $x\equiv \pm 1 \pmod p$。

它还是比较容易证明的。

由于 $x^2\equiv 1 \pmod p$，所以 $x^2-1\equiv 0 \pmod p$，即 $p \mid (x+1)(x-1)$。

又因为 $p$ 是质数，所以要么 $p \mid x+1$，要么 $p \mid x-1$，所以 $x^2\equiv 1 \pmod p$ 的解为 $x\equiv \pm 1 \pmod p$。

## 2.3 Miller-Rabin 算法

根据二次探测定理，我们可以对费马素性检验进行优化，得到 Miller-Rabin 素性检验。

设我们需要进行检验的数为 $p$，其中 $p$ 为不小于 $3$ 的奇数，那么检验过程如下：

1. 令 $p-1=2^k\cdot q$，其中 $k>0$，$q$ 为奇数；

2. 随机选取一个底数 $a$，其中 $a \in (1,p-1)$；

3. 若 $a^q \not\equiv 1 \pmod p$ 且**不存在**小于 $k$ 的非负整数 $j$ 满足 $a^{2^j \cdot q} \equiv -1 \pmod p$，则 $p$ 为合数，否则 $p$ **大概率**为素数。

其中，进行一次 Miller-Rabin 素性检验的错误概率大约为 $4^{-1}$，那我们可以通过多次选取底数 $a$ 来达到减小错误概率的目的。

设选取底数的次数为 $s$，则错误概率约为 $4^{-s}$，大约选取 $20$ 个底数就足够了。

实际上，若我们选取前 $12$ 小的质数作为底数，即 $2,3,5,7,11,13,17,19,23,29,31,37$，可以完全正确地对 $2^{78}$ 以内的数进行素性检验。这在 OI 范围内已经完全够用了。

## 2.4 代码实现

```c++
typedef long long ll;
typedef __int128 i128;
int a[12]={2,3,5,7,11,13,17,19,23,29,31,37};
ll ksm(i128 a,ll b,ll m){
	ll res=1;
	while(b){
		if(b&1) res=res*a%m;
		a=a*a%m,b>>=1;
	}
	return res;
}
bool check(ll n){
	if(n==2) return 1;
	if(n<2||n%2==0) return 0;
	for(int t=0;t<12&&a[t]<n;t++){
		ll p=n,d=p-1;
		i128 x;
		bool flag=0;
		while(d%2==0){
			d=d/2,x=ksm(a[t],d,p);
			if(x==p-1) flag=1;
		}
		if(!flag&&ksm(a[t],d,p)!=1) return 0;
	}
	return 1;
}
```